{
  "version": 3,
  "sources": ["../src/position-calculator.js"],
  "sourcesContent": ["/*!\r\n * class PositionCalculator\r\n * https://github.com/tlindig/position-calculator\r\n *\r\n * Copyright (c) 2014 Tobias Lindig\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/*global define:false, module:false*/\r\n(function(factory) {\r\n    // make it public\r\n    if (typeof define === 'function' && define.amd) {\r\n        // as __named__ AMD module\r\n        define(\"position-calculator\", [\"jquery\"], factory);\r\n    } else if (typeof module === 'object' && module.exports) {\r\n        module.exports = factory;\r\n    } else {\r\n        // as Browser globals\r\n        jQuery.PositionCalculator = factory(jQuery);\r\n    }\r\n}(function($) {\r\n    \"use strict\"; //enable ECMAScript 5 Strict Mode\r\n\r\n    // //////////\r\n    // private\r\n    var __window = window;\r\n    var __document = document;\r\n    var __docElement = __document.documentElement;\r\n\r\n    var __rgx_vertical = /top|middle|bottom/;\r\n    var __rgx_horizontal = /left|center|right/;\r\n    var __rgx_percent = /%$/;\r\n\r\n    var __mirror = {\r\n        left: \"right\",\r\n        center: \"center\",\r\n        right: \"left\",\r\n        top: \"bottom\",\r\n        middle: \"middle\",\r\n        bottom: \"top\"\r\n    };\r\n\r\n    /**\r\n     * prepare selector, because jQuery do not return \"window\" and \"document\"\r\n     *\r\n     * @param  {selector|DOM|jQuery|null} selector value given in options\r\n     * @return {selector|DOM|jQuery|null}  if \"selector\" was a string and match \"window\" or\r\n     *                                     \"document\", than the native object will be returned.\r\n     */\r\n    function __normalizeSlector(selector) {\r\n        if (typeof selector === \"string\") {\r\n            if (selector === \"window\") {\r\n                selector = __window;\r\n            } else if (selector === \"document\") {\r\n                selector = __document;\r\n            }\r\n        }\r\n        return selector;\r\n    }\r\n\r\n    /**\r\n     * Normalize the given \"at\" specification.\r\n     * Use default value ('top left'), if syntax is not correct.\r\n     *\r\n     * @param  {string} ref     syntax: <vertical> + \" \" + <horizontal>\r\n     *                          vertical: \"top\" | \"middle\" | \"bottom\"\r\n     *                          horizontal: \"left\" | \"center\" | \"right\"\r\n     * @return {NormAt}         Object with {y:string, x:string}\r\n     */\r\n    function __normalizeAt(ref) {\r\n        var values = ref.split(\" \");\r\n        return {\r\n            y: __rgx_vertical.test(values[0]) ? values[0] : \"top\",\r\n            x: __rgx_horizontal.test(values[1]) ? values[1] : \"left\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * compare to NormPos with {top:number, left:number, height:number, width:number}\r\n     *\r\n     * @param  {NormPos} normPos1\r\n     * @param  {NormPos} normPos2\r\n     * @return {boolean}          true, if values are equal\r\n     */\r\n    function __isEqualNormPos(normPos1, normPos2) {\r\n        if (normPos1 === normPos2) {\r\n            return true;\r\n        }\r\n        if(!normPos1 || !normPos2) {\r\n            return false;\r\n        }\r\n        return (normPos1.top === normPos2.top && normPos1.left === normPos2.left &&\r\n            normPos1.height === normPos2.height && normPos1.width === normPos2.width);\r\n    }\r\n\r\n    /**\r\n     * read the correct value for top, left, width and height from the given $el.\r\n     * Can handle \"window\", \"document\", \"event\" and \"DOM node\"\r\n     * resulting \"top\" and \"left\" are relative to document top-left corner\r\n     *\r\n     * @param  {jQuery} $el     input to calculate the position\r\n     * @return {NormPos}        Object with {top:number, left:number, height:number, width:number}\r\n     *\r\n     **/\r\n    function __nomrmalizePosition($el) {\r\n        var raw = $el[0];\r\n        if (raw.nodeType === 9) {\r\n            // is document node\r\n            return {\r\n                width: $el.outerWidth(),\r\n                height: $el.outerHeight(),\r\n                top: 0,\r\n                left: 0\r\n            };\r\n        }\r\n        if ($.isWindow(raw)) {\r\n            return {\r\n                width: $el.outerWidth(),\r\n                height: $el.outerHeight(),\r\n                top: $el.scrollTop(),\r\n                left: $el.scrollLeft()\r\n            };\r\n        }\r\n        if (raw.preventDefault) {\r\n            // is event\r\n            return {\r\n                width: 0,\r\n                height: 0,\r\n                top: raw.pageY,\r\n                left: raw.pageX\r\n            };\r\n        }\r\n        var offset = $el.offset();\r\n        return {\r\n            width: $el.outerWidth(),\r\n            height: $el.outerHeight(),\r\n            top: offset.top,\r\n            left: offset.left\r\n        };\r\n    }\r\n\r\n    function __refreshPosition($el, normPos) {\r\n        var raw = $el[0];\r\n        if (raw.nodeType === 9) {\r\n            // is document node, top and left are always 0\r\n            return;\r\n        }\r\n        if ($.isWindow(raw)) {\r\n            normPos.top = $el.scrollTop();\r\n            normPos.left = $el.scrollLeft();\r\n        }\r\n        if (raw.preventDefault) {\r\n            // is event\r\n            normPos.top = raw.pageY;\r\n            normPos.left = raw.pageX;\r\n            return;\r\n        }\r\n\r\n        var offset = $el.offset();\r\n        normPos.top = offset.top;\r\n        normPos.left = offset.left;\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * get the inner boundary box of given element. Take care of scrollbars, borders, padding and so on.\r\n     * Can handle \"window\", \"document\" and \"DOM node\"\r\n     * resulting \"top\" and \"left\" are relative to document top-left corner\r\n     *\r\n     * @param  {jQuery} $el [description]\r\n     * @return {NormPos}    Object with {top:number, left:number, height:number, width:number}\r\n     */\r\n    function __normalizeBounding($el) {\r\n        var domElm = $el[0];\r\n        var offset;\r\n        if (domElm.nodeType === 9) {\r\n            // is document node\r\n            domElm = __docElement;\r\n            offset = {\r\n                top: 0,\r\n                left: 0\r\n            };\r\n        } else if ($.isWindow(domElm)) {\r\n            domElm = __docElement;\r\n            offset = {\r\n                top: $el.scrollTop(),\r\n                left: $el.scrollLeft()\r\n            };\r\n        } else {\r\n            offset = $el.offset();\r\n        }\r\n\r\n        return {\r\n            width: domElm.clientWidth,\r\n            height: domElm.clientHeight,\r\n            top: offset.top + domElm.clientTop,\r\n            left: offset.left + domElm.clientLeft\r\n        };\r\n    }\r\n\r\n    function __refreshBounding($el, normPos) {\r\n        var domElm = $el[0];\r\n        var offset;\r\n        if (domElm.nodeType === 9) {\r\n            // is document node\r\n            domElm = __docElement;\r\n            offset = {\r\n                top: 0,\r\n                left: 0\r\n            };\r\n        } else if ($.isWindow(domElm)) {\r\n            domElm = __docElement;\r\n            offset = {\r\n                top: $el.scrollTop(),\r\n                left: $el.scrollLeft()\r\n            };\r\n        } else {\r\n            offset = $el.offset();\r\n        }\r\n\r\n        normPos.top = offset.top + domElm.clientTop;\r\n        normPos.left = offset.left + domElm.clientLeft;\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * normalize given offset, convert percent values in pixel values.\r\n     *\r\n     * @param  {Object} offset      offset object with property x:{number}, y:{number}, mirror:{boolean}\r\n     * @param  {Object} size        with properties width:{number} and height:{number} }\r\n     * @return {Object}             offset object\r\n     */\r\n    function __normalizeExtraOffset(offset, size) {\r\n        return {\r\n            y: parseFloat(offset.y) * (__rgx_percent.test(offset.y) ? size.height / 100 :\r\n                1),\r\n            x: parseFloat(offset.x) * (__rgx_percent.test(offset.x) ? size.width / 100 :\r\n                1),\r\n            mirror: offset.mirror\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calculate the relative offset from top-left corner to the reference points\r\n     *\r\n     * @param  {NormPos} pos          Object with normalized position\r\n     * @param  {{x:number, y:number}} extraOffsets    [description]\r\n     * @param  {{x:string, y:string}} initialRefpoint [description]\r\n     * @return {RefPoints}            Object with offset for reference points\r\n     *                                { top:number, left:number, middle:number,\r\n     *                                  center:number, bottom:number, right:number }\r\n     */\r\n    function __calculateRefpointOffsets(pos, extraOffsets, initialRefpoint) {\r\n        var result = {\r\n            top: 0,\r\n            left: 0,\r\n            middle: pos.height * 0.5,\r\n            center: pos.width * 0.5,\r\n            bottom: pos.height,\r\n            right: pos.width\r\n        };\r\n\r\n        //add extra offset\r\n        if (extraOffsets.y !== 0) {\r\n            result.middle += extraOffsets.y;\r\n            if (extraOffsets.mirror) {\r\n                result.top += (\"top\" !== initialRefpoint.y) ? (extraOffsets.y * -1) :\r\n                    extraOffsets.y;\r\n                result.bottom += (\"bottom\" !== initialRefpoint.y) ? (extraOffsets.y * -1) :\r\n                    extraOffsets.y;\r\n            } else {\r\n                result.top += extraOffsets.y;\r\n                result.bottom += extraOffsets.y;\r\n            }\r\n        }\r\n        if (extraOffsets.x !== 0) {\r\n            result.center += extraOffsets.x;\r\n            if (extraOffsets.mirror) {\r\n                result.left += (\"left\" !== initialRefpoint.x) ? (extraOffsets.x * -1) :\r\n                    extraOffsets.x;\r\n                result.right += (\"right\" !== initialRefpoint.x) ? (extraOffsets.x * -1) :\r\n                    extraOffsets.x;\r\n            } else {\r\n                result.left += extraOffsets.x;\r\n                result.right += extraOffsets.x;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * collect all edges that have overflow between boundary and item.\r\n     *\r\n     * @param  {Distance} distance  Distance Object\r\n     * @return {Distance}           Object with\r\n     *                              { top:number, left:number, bottom:number, right:number,\r\n     *                                overflow:{Array.<string>|null} }\r\n     */\r\n    function __updateOverflow(distance) {\r\n        var overflow = [];\r\n        distance.top > 0 && overflow.push(\"top\");\r\n        distance.left > 0 && overflow.push(\"left\");\r\n        distance.bottom < 0 && overflow.push(\"bottom\");\r\n        distance.right < 0 && overflow.push(\"right\");\r\n\r\n        if (overflow.length) {\r\n            distance.overflow = overflow;\r\n        } else {\r\n            distance.overflow = null;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * calculate distance / overflow between boundary and item.\r\n     *\r\n     * @param  {NormPos} bou_Pos    NormPos of boundary\r\n     * @param  {NormPos} item_Pos   NormPos of item\r\n     * @return {Distance}           Object with\r\n     *                              { top:number, left:number, bottom:number, right:number,\r\n     *                                overflow:{Array.<string>|null} }\r\n     */\r\n    function __calulateDistance(bou_Pos, item_Pos) {\r\n        var result = {\r\n            top: bou_Pos.top - item_Pos.top,\r\n            left: bou_Pos.left - item_Pos.left,\r\n            bottom: (bou_Pos.top + bou_Pos.height) - (item_Pos.top + item_Pos.height),\r\n            right: (bou_Pos.left + bou_Pos.width) - (item_Pos.left + item_Pos.width),\r\n            overflow: []\r\n        };\r\n\r\n        return __updateOverflow(result);\r\n    }\r\n\r\n    /**\r\n     * calculate the new fliped placement.\r\n     *\r\n     * {NormAt} is Object with {x:string, y:string}\r\n     *\r\n     * @param  {string} flip    - flip option, \"item\", \"target\", \"both\", \"none\"\r\n     * @param  {NormAt} itemAt  - NormAt of item\r\n     * @param  {NormAt} tarAt   - NormAt of target\r\n     * @param  {Distance}       - current calculated distance, needed to find out, which edge have overflow\r\n     * @return {Object|null}    - Object with placement\r\n     *                          {\r\n     *                              item_at:NormAt,\r\n     *                              tar_at:NormAt\r\n     *                          }\r\n     *                          - null, if no overflow or if overflow on all edges\r\n     */\r\n    function __flipPlacement(flip, itemAt, tarAt, distance) {\r\n        var y_overflowEdge, x_overflowEdge, flipBits;\r\n        var item_flipedAt = {\r\n            y: itemAt.y,\r\n            x: itemAt.x\r\n        };\r\n        var tar_flipedAt = {\r\n            y: tarAt.y,\r\n            x: tarAt.x\r\n        };\r\n\r\n        if (distance.overflow.indexOf(\"top\") !== -1) {\r\n            y_overflowEdge = \"top\";\r\n        }\r\n        if (distance.overflow.indexOf(\"bottom\") !== -1) {\r\n            if (y_overflowEdge) {\r\n                //overflow in both sides, so item is larger than boundary. Can't be resolved\r\n                y_overflowEdge = null;\r\n            } else {\r\n                y_overflowEdge = \"bottom\";\r\n            }\r\n        }\r\n\r\n        if (distance.overflow.indexOf(\"left\") !== -1) {\r\n            x_overflowEdge = \"left\";\r\n        }\r\n        if (distance.overflow.indexOf(\"right\") !== -1) {\r\n            if (x_overflowEdge) {\r\n                //overflow in both sides, so item is larger than boundary. Can't be resolved\r\n                x_overflowEdge = null;\r\n            } else {\r\n                x_overflowEdge = \"right\";\r\n            }\r\n        }\r\n\r\n        if (!y_overflowEdge && !x_overflowEdge) {\r\n            return null;\r\n        }\r\n\r\n        flip = (flip === true) ? \"both\" : flip;\r\n        flipBits = 0;\r\n        switch (flip) {\r\n            case \"item\":\r\n                flipBits = 1;\r\n                break;\r\n            case \"target\":\r\n                flipBits = 2;\r\n                break;\r\n            case \"both\":\r\n                flipBits = 3;\r\n                break;\r\n        }\r\n\r\n        if (flipBits & 1) {\r\n            y_overflowEdge && (item_flipedAt.y = __mirror[item_flipedAt.y]);\r\n            x_overflowEdge && (item_flipedAt.x = __mirror[item_flipedAt.x]);\r\n        }\r\n        if (flipBits & 2) {\r\n            y_overflowEdge && (tar_flipedAt.y = __mirror[tar_flipedAt.y]);\r\n            x_overflowEdge && (tar_flipedAt.x = __mirror[tar_flipedAt.x]);\r\n        }\r\n\r\n        return {\r\n            item_at: item_flipedAt,\r\n            tar_at: tar_flipedAt\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * compare overflow in distancaA with overflow in distanceB.\r\n     *\r\n     * @param  {Distance}  distanceA  distance object, with top, right, bottom, left\r\n     * @param  {Distance}  distanceB  distance object, with top, right, bottom, left\r\n     * @param  {boolean} isY        axis\r\n     * @return {boolean}            return true, if overflow of A is less than overflow of B,\r\n     *                                         otherwise false\r\n     */\r\n    function __overflowLT(distanceA, distanceB, isY) {\r\n        var a1, a2, b1, b2, edges;\r\n\r\n        if (isY) {\r\n            edges = [\"top\", \"bottom\"];\r\n        } else {\r\n            edges = [\"left\", \"right\"];\r\n        }\r\n        a1 = distanceA[edges[0]];\r\n        b1 = distanceB[edges[0]];\r\n        a2 = distanceA[edges[1]] * -1; // * -1 to get positive values for overflow\r\n        b2 = distanceB[edges[1]] * -1;\r\n\r\n        // set values without overflow to zero\r\n        a1 < 0 && (a1 = 0);\r\n        a2 < 0 && (a2 = 0);\r\n        b1 < 0 && (b1 = 0);\r\n        b2 < 0 && (b2 = 0);\r\n\r\n        if (a1 < 0 && a2 < 0) {\r\n            //take a\r\n            return true;\r\n        }\r\n\r\n        if (b1 < 0 && b2 < 0) {\r\n            // take b\r\n            return false;\r\n        }\r\n\r\n        return (a1 + a2) < (b1 + b2);\r\n    }\r\n\r\n    function __adaptSticking(data, edges) {\r\n        if (edges === \"all\") {\r\n            edges = true;\r\n        }\r\n        var overflow = data.distance.overflow;\r\n\r\n        if(!overflow.length) {\r\n            return data;\r\n        }\r\n\r\n        //to prevent handling overflow in both directions of on axis\r\n        var skipX = false;\r\n        var skipY = false;\r\n\r\n        var edge, diff;\r\n        for (var i = overflow.length - 1; i >= 0; i--) {\r\n            edge = overflow[i];\r\n            switch (edge) {\r\n                case \"top\":\r\n                case \"bottom\":\r\n                    if (!skipY && edges === true || edges.indexOf(edge) !== -1) {\r\n                        diff = data.distance[edge];\r\n                        data.moveBy.y += diff;\r\n                        data.distance.top -= diff;\r\n                        data.distance.bottom -= diff;\r\n                        skipY = true;\r\n                    }\r\n                    break;\r\n\r\n                case \"left\":\r\n                case \"right\":\r\n                    if (!skipX && edges === true || edges.indexOf(edge) !== -1) {\r\n                        diff = data.distance[edge];\r\n                        data.moveBy.x += diff;\r\n                        data.distance.left -= diff;\r\n                        data.distance.right -= diff;\r\n                        skipX = true;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        __updateOverflow(data.distance);\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Class PositionCalculator\r\n     *\r\n     * @param {Object} options\r\n     *\r\n     * {selector|DOM|jQuery} item       -required- the element being positioned\r\n     * {selector|DOM|jQuery} target     -required- the element align the positioned item against\r\n     * {selector|DOM|jQuery|null} boundary -optional- constraints the position of item\r\n     *                                      default: window\r\n     *\r\n     * {string} itemAt          -optional- placement of reference point on the item\r\n     *                                   syntax: <vertical> + \" \" + <horizontal>\r\n     *                                   vertical: \"top\" | \"middle\" | \"bottom\"\r\n     *                                   horizontal: \"left\" | \"center\" | \"right\"\r\n     *                          default: \"top left\"\r\n     * {string} targetAt        -optional- placement of reference point on the target\r\n     *                                     same as for \"itemAt\"\r\n     *                          default: \"top left\"\r\n     * {Object} itemOffset      -optional- Object with {\r\n     *                                         y:number,      // vertical offset\r\n     *                                         x:number,      // horizontal offset\r\n     *                                         mirror:boolean // if offset should mirror for flip\r\n     *                                    }\r\n     *                          default: { y:0, x:0, mirror:true }\r\n     *\r\n     * {Object} targetOffset    -optional- same as for \"itemOffset\"\r\n     *                          default: { y:0, x:0, mirror:true }\r\n     *\r\n     * {string|boolean} flip    -optional- specify the strategy to prevent that \"item\"\r\n     *                                    overflows the boundary.\r\n     *                                    \"item\": Only change the itemAt\r\n     *                                    \"target\": Only change the targetAt\r\n     *                                    \"both\"|true: Change both the itemAt and targetAt at the same time\r\n     *                                          (to 'flip' the item to the other side of the target)\r\n     *                                    \"none\"|false: Don't change placement of reference point\r\n     *                          default: \"none\"\r\n     *\r\n     * {string|boolean} stick   -optional- will keep the item within it's boundary by sticking it to\r\n     *                                     the edges if it normally would overflow.\r\n     *                                     Specify sides you'd like to control (space separated) or\r\n     *                                     \"none\"|false or \"all\"|true.\r\n     *                          default: \"none\"\r\n     *\r\n     *\r\n     *  Main method is calculate()\r\n     *\r\n     */\r\n    function PositionCalculator(options) {\r\n        //ensure it called with 'new'\r\n        if (!(this instanceof PositionCalculator)) {\r\n            return new PositionCalculator(options);\r\n        }\r\n\r\n        this.options =\r\n            this.$itm =\r\n            this.$trg =\r\n            this.$bnd =\r\n            this.itmAt =\r\n            this.trgAt =\r\n            this.itmPos =\r\n            this.trgPos =\r\n            this.bndPos =\r\n            this.itmOffset =\r\n            this.trgOffset = null;\r\n\r\n        this._init(options);\r\n    }\r\n    PositionCalculator.prototype._init = function(options) {\r\n        var o = this.options = $.extend({}, PositionCalculator.defaults, options);\r\n\r\n        if (!o.item) {\r\n            return null;\r\n        }\r\n        this.$itm = o.item.jquery ? o.item : $(o.item);\r\n        if (this.$itm.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        this.$trg = o.target && o.target.jquery ? o.target : $(__normalizeSlector(o.target));\r\n        this.$bnd = o.boundary && o.boundary.jquery ? o.boundary : $(__normalizeSlector(o.boundary));\r\n\r\n        this.itmAt = __normalizeAt(o.itemAt);\r\n        this.trgAt = __normalizeAt(o.targetAt);\r\n\r\n        this.resize();\r\n\r\n        return this; // to allow chaining\r\n    };\r\n\r\n    /**\r\n     * Update intern stored values depending on size and position of elements (item, target, boundary).\r\n     * Should be called if dimensions of an element changed.\r\n     *\r\n     * @return {this} allow chaining\r\n     */\r\n    PositionCalculator.prototype.resize = function() {\r\n        var o = this.options;\r\n\r\n        var item_pos = __nomrmalizePosition(this.$itm);\r\n        var targ_pos = this.$trg.length ? __nomrmalizePosition(this.$trg) : null;\r\n        this.bndPos = this.$bnd.length ? __normalizeBounding(this.$bnd) : null;\r\n\r\n        if (!this.itmPos || !__isEqualNormPos(item_pos, this.itmPos)) {\r\n            this.itmPos = item_pos;\r\n            var item_extraOffset = __normalizeExtraOffset(o.itemOffset, item_pos);\r\n            // negate values, because it shall be defined relative to the item reference point\r\n            // and not relative to the corner.\r\n            item_extraOffset.x = item_extraOffset.x * -1;\r\n            item_extraOffset.y = item_extraOffset.y * -1;\r\n\r\n            this.itmOffset = __calculateRefpointOffsets(item_pos, item_extraOffset,\r\n                this.itmAt);\r\n        }\r\n        if (!this.trgPos || !__isEqualNormPos(targ_pos, this.trgPos)) {\r\n            this.trgPos = targ_pos;\r\n            if(targ_pos) {\r\n                this.trgOffset = __calculateRefpointOffsets(\r\n                    targ_pos,\r\n                    __normalizeExtraOffset(o.targetOffset, targ_pos),\r\n                    this.trgAt\r\n                );\r\n            }\r\n        }\r\n\r\n        return this; // to allow chaining\r\n    };\r\n\r\n    /**\r\n     * Calculate the resulting position and boundary distance for the given placement.\r\n     * That will not handle flip and fit.\r\n     *\r\n     * If target was not specified, only boundary distance will be calculated.\r\n     * If not \"item_at\" or \"tar_at\", only boundary distance will be calculated.\r\n     * If boundary was set to null, only new position will be calculated.\r\n     *\r\n     * Current position of elements (item, target, boundary) will be read from DOM.\r\n     *\r\n     * @param  {{x:string, y:string}|null} item_at Placement for reference point on item\r\n     * @param  {{x:string, y:string}|null} tar_at  Placement for reference point on target\r\n     * @return {Object}         CalculationResult, see method calculate()\r\n     */\r\n    PositionCalculator.prototype.calcVariant = function(item_at, tar_at) {\r\n        var result = {\r\n            moveBy: null,\r\n            distance: null,\r\n            itemAt: null,\r\n            targetAt: null\r\n        };\r\n\r\n        if(this.trgPos && item_at && tar_at) {\r\n            var tar_refpoint = {\r\n                top: this.trgPos.top + this.trgOffset[tar_at.y],\r\n                left: this.trgPos.left + this.trgOffset[tar_at.x]\r\n            };\r\n            var item_newPos = {\r\n                top: tar_refpoint.top - this.itmOffset[item_at.y],\r\n                left: tar_refpoint.left - this.itmOffset[item_at.x],\r\n                height: this.itmPos.height,\r\n                width: this.itmPos.width\r\n            };\r\n\r\n            result.moveBy = {\r\n                y: item_newPos.top - this.itmPos.top,\r\n                x: item_newPos.left - this.itmPos.left\r\n            };\r\n            result.distance = this.bndPos ? __calulateDistance(this.bndPos, item_newPos) : null;\r\n            result.itemAt = item_at.y + \" \" + item_at.x;\r\n            result.targetAt = tar_at.y + \" \" + tar_at.x;\r\n        } else {\r\n            result.moveBy = { y:0, x:0 };\r\n            result.distance = this.bndPos ? __calulateDistance(this.bndPos, this.itmPos) : null;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Calculate the distance between reference point of item and reference point of target and\r\n     * handle overflow in the specified matter.\r\n     *\r\n     * @return {Object}   with:\r\n     *     moveBy: {{y:number, x:number}} - distance between target and item as pixel values\r\n     *     distance: {Distance|null}    - distance between item and boundary\r\n     *                                      null, if boundary was not given\r\n     *                                  Distance is Object with: {\r\n     *                                      top:number, left:number,\r\n     *                                      bottom:number, right:number,\r\n     *                                      overflow:{Array.<string>|null}\r\n     *                                  }\r\n     *                                  - top, left, buttom, right - distance/overflow for this edge\r\n     *                                  - overflow - Array with edges has overflow\r\n     *                                             - null for no collision detected\r\n     *     itemAt: {string|null}        - used placement of reference point at item\r\n     *                                    syntax: <vertical> + \" \" + <horizontal>\r\n     *                                    vertical: \"top\" | \"middle\" | \"bottom\"\r\n     *                                    horizontal: \"left\" | \"center\" | \"right\"\r\n     *                                  - null, if target was not given\r\n     *     targetAt: {string|null}      - used placement of reference point at target\r\n     *                                    syntax: <vertical> + \" \" + <horizontal>\r\n     *                                    vertical: \"top\" | \"middle\" | \"bottom\"\r\n     *                                    horizontal: \"left\" | \"center\" | \"right\"\r\n     *                                  - null, if target was not given\r\n     */\r\n    PositionCalculator.prototype.calculate = function() {\r\n        if (this.itmPos === null) {\r\n            return null; // init failed\r\n        }\r\n\r\n        var o = this.options;\r\n\r\n        // refresh\r\n        // only update the position off elements and scroll offsets, but not the width or height\r\n        __refreshPosition(this.$itm, this.itmPos);\r\n        this.trgPos && __refreshPosition(this.$trg, this.trgPos);\r\n        this.bndPos && __refreshBounding(this.$bnd, this.bndPos);\r\n\r\n        var result = this.calcVariant(this.itmAt, this.trgAt);\r\n        if (!result.distance || !result.distance.overflow) {\r\n            //finish, because no collision\r\n            return result;\r\n        }\r\n\r\n        // ////////////////////\r\n        // collision handling: flip\r\n        if (o.flip && o.flip !== \"none\" && this.trgPos) {\r\n            var newResult;\r\n            var flipedPlacement = __flipPlacement(o.flip, this.itmAt, this.trgAt,\r\n                result.distance);\r\n\r\n            if (flipedPlacement) {\r\n                newResult = this.calcVariant(flipedPlacement.item_at, flipedPlacement.tar_at);\r\n\r\n                if (!newResult.distance.overflow) {\r\n                    //finish, because found placement without collision\r\n                    return newResult;\r\n                }\r\n\r\n                // look for combination with fewest overflow\r\n                var useNew = {\r\n                    y: false,\r\n                    x: false\r\n                };\r\n                useNew.y = __overflowLT(newResult.distance, result.distance, true);\r\n                useNew.x = __overflowLT(newResult.distance, result.distance, false);\r\n\r\n                if (useNew.y !== useNew.x) {\r\n                    //need new distance calculation\r\n                    result = this.calcVariant({\r\n                        y: useNew.y ? flipedPlacement.item_at.y : this.itmAt.y,\r\n                        x: useNew.x ? flipedPlacement.item_at.x : this.itmAt.x\r\n                    }, {\r\n                        y: useNew.y ? flipedPlacement.tar_at.y : this.trgAt.y,\r\n                        x: useNew.x ? flipedPlacement.tar_at.x : this.trgAt.x\r\n                    });\r\n                    if (!result.distance.overflow) {\r\n                        //finish, because found position without collision\r\n                        return result;\r\n                    }\r\n                } else if (useNew.y && useNew.x) {\r\n                    result = newResult;\r\n                } // else use \"old\" result\r\n            }\r\n        }\r\n\r\n        // ////////////////////\r\n        // collision handling: stick\r\n        if (o.stick && o.stick !== \"none\") {\r\n            return __adaptSticking(result, o.stick);\r\n        } else {\r\n            return result;\r\n        }\r\n    };\r\n\r\n    // default options\r\n    PositionCalculator.defaults = {\r\n        item: null,\r\n        target: null,\r\n        boundary: window,\r\n        itemAt: \"top left\",\r\n        targetAt: \"top left\",\r\n        itemOffset: {\r\n            y: 0,\r\n            x: 0,\r\n            mirror: true\r\n        },\r\n        targetOffset: {\r\n            y: 0,\r\n            x: 0,\r\n            mirror: true\r\n        },\r\n        flip: \"none\",\r\n        stick: \"none\"\r\n    };\r\n\r\n    // export\r\n    return PositionCalculator;\r\n}));\r\n"],
  "mappings": "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",
  "names": ["factory", "$", "__window", "__document", "__docElement", "__rgx_vertical", "__rgx_horizontal", "__rgx_percent", "__mirror", "__normalizeSlector", "selector", "__normalizeAt", "ref", "values", "__isEqualNormPos", "normPos1", "normPos2", "__nomrmalizePosition", "$el", "raw", "offset", "__refreshPosition", "normPos", "__normalizeBounding", "domElm", "__refreshBounding", "__normalizeExtraOffset", "size", "__calculateRefpointOffsets", "pos", "extraOffsets", "initialRefpoint", "result", "__updateOverflow", "distance", "overflow", "__calulateDistance", "bou_Pos", "item_Pos", "__flipPlacement", "flip", "itemAt", "tarAt", "y_overflowEdge", "x_overflowEdge", "flipBits", "item_flipedAt", "tar_flipedAt", "__overflowLT", "distanceA", "distanceB", "isY", "a1", "a2", "b1", "b2", "edges", "__adaptSticking", "data", "skipX", "skipY", "edge", "diff", "i", "PositionCalculator", "options", "o", "item_pos", "targ_pos", "item_extraOffset", "item_at", "tar_at", "tar_refpoint", "item_newPos", "newResult", "flipedPlacement", "useNew"]
}
