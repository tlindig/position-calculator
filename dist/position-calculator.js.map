{
  "version": 3,
  "sources": ["../src/position-calculator.js"],
  "sourcesContent": ["/*!\r\n * class PositionCalculator\r\n * https://github.com/tlindig/position-calculator\r\n *\r\n * Copyright (c) 2014 Tobias Lindig\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/*global define:false, module:false*/\r\n(function(factory) {\r\n    // make it public\r\n    if (typeof define === 'function' && define.amd) {\r\n        // as __named__ AMD module\r\n        define(\"position-calculator\", [\"jquery\"], factory);\r\n    } else if (typeof module === 'object' && module.exports) {\r\n        module.exports = factory;\r\n    } else {\r\n        // as Browser globals\r\n        jQuery.PositionCalculator = factory(jQuery);\r\n    }\r\n}(function($) {\r\n    \"use strict\"; //enable ECMAScript 5 Strict Mode\r\n\r\n    // //////////\r\n    // private\r\n    var __window = window;\r\n    var __document = document;\r\n    var __docElement = __document.documentElement;\r\n\r\n    var __rgx_vertical = /top|middle|bottom/;\r\n    var __rgx_horizontal = /left|center|right/;\r\n    var __rgx_percent = /%$/;\r\n\r\n    var __mirror = {\r\n        left: \"right\",\r\n        center: \"center\",\r\n        right: \"left\",\r\n        top: \"bottom\",\r\n        middle: \"middle\",\r\n        bottom: \"top\"\r\n    };\r\n\r\n    /**\r\n     * prepare selector, because jQuery do not return \"window\" and \"document\"\r\n     *\r\n     * @param  {selector|DOM|jQuery|null} selector value given in options\r\n     * @return {selector|DOM|jQuery|null}  if \"selector\" was a string and match \"window\" or\r\n     *                                     \"document\", than the native object will be returned.\r\n     */\r\n    function __normalizeSlector(selector) {\r\n        if (typeof selector === \"string\") {\r\n            if (selector === \"window\") {\r\n                selector = __window;\r\n            } else if (selector === \"document\") {\r\n                selector = __document;\r\n            }\r\n        }\r\n        return selector;\r\n    }\r\n\r\n    /**\r\n     * Normalize the given \"at\" specification.\r\n     * Use default value ('top left'), if syntax is not correct.\r\n     *\r\n     * @param  {string} ref     syntax: <vertical> + \" \" + <horizontal>\r\n     *                          vertical: \"top\" | \"middle\" | \"bottom\"\r\n     *                          horizontal: \"left\" | \"center\" | \"right\"\r\n     * @return {NormAt}         Object with {y:string, x:string}\r\n     */\r\n    function __normalizeAt(ref) {\r\n        var values = ref.split(\" \");\r\n        return {\r\n            y: __rgx_vertical.test(values[0]) ? values[0] : \"top\",\r\n            x: __rgx_horizontal.test(values[1]) ? values[1] : \"left\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * compare to NormPos with {top:number, left:number, height:number, width:number}\r\n     *\r\n     * @param  {NormPos} normPos1\r\n     * @param  {NormPos} normPos2\r\n     * @return {boolean}          true, if values are equal\r\n     */\r\n    function __isEqualNormPos(normPos1, normPos2) {\r\n        if (normPos1 === normPos2) {\r\n            return true;\r\n        }\r\n        if(!normPos1 || !normPos2) {\r\n            return false;\r\n        }\r\n        return (normPos1.top === normPos2.top && normPos1.left === normPos2.left &&\r\n            normPos1.height === normPos2.height && normPos1.width === normPos2.width);\r\n    }\r\n\r\n    /**\r\n     * read the correct value for top, left, width and height from the given $el.\r\n     * Can handle \"window\", \"document\", \"event\" and \"DOM node\"\r\n     * resulting \"top\" and \"left\" are relative to document top-left corner\r\n     *\r\n     * @param  {jQuery} $el     input to calculate the position\r\n     * @return {NormPos}        Object with {top:number, left:number, height:number, width:number}\r\n     *\r\n     **/\r\n    function __nomrmalizePosition($el) {\r\n        var raw = $el[0];\r\n        if (raw.nodeType === 9) {\r\n            // is document node\r\n            return {\r\n                width: $el.outerWidth(),\r\n                height: $el.outerHeight(),\r\n                top: 0,\r\n                left: 0\r\n            };\r\n        }\r\n        if ($.isWindow(raw)) {\r\n            return {\r\n                width: $el.outerWidth(),\r\n                height: $el.outerHeight(),\r\n                top: $el.scrollTop(),\r\n                left: $el.scrollLeft()\r\n            };\r\n        }\r\n        if (raw.preventDefault) {\r\n            // is event\r\n            return {\r\n                width: 0,\r\n                height: 0,\r\n                top: raw.pageY,\r\n                left: raw.pageX\r\n            };\r\n        }\r\n        var offset = $el.offset();\r\n        return {\r\n            width: $el.outerWidth(),\r\n            height: $el.outerHeight(),\r\n            top: offset.top,\r\n            left: offset.left\r\n        };\r\n    }\r\n\r\n    function __refreshPosition($el, normPos) {\r\n        var raw = $el[0];\r\n        if (raw.nodeType === 9) {\r\n            // is document node, top and left are always 0\r\n            return;\r\n        }\r\n        if ($.isWindow(raw)) {\r\n            normPos.top = $el.scrollTop();\r\n            normPos.left = $el.scrollLeft();\r\n        }\r\n        if (raw.preventDefault) {\r\n            // is event\r\n            normPos.top = raw.pageY;\r\n            normPos.left = raw.pageX;\r\n            return;\r\n        }\r\n\r\n        var offset = $el.offset();\r\n        normPos.top = offset.top;\r\n        normPos.left = offset.left;\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * get the inner boundary box of given element. Take care of scrollbars, borders, padding and so on.\r\n     * Can handle \"window\", \"document\" and \"DOM node\"\r\n     * resulting \"top\" and \"left\" are relative to document top-left corner\r\n     *\r\n     * @param  {jQuery} $el [description]\r\n     * @return {NormPos}    Object with {top:number, left:number, height:number, width:number}\r\n     */\r\n    function __normalizeBounding($el) {\r\n        var domElm = $el[0];\r\n        var offset;\r\n        if (domElm.nodeType === 9) {\r\n            // is document node\r\n            domElm = __docElement;\r\n            offset = {\r\n                top: 0,\r\n                left: 0\r\n            };\r\n        } else if ($.isWindow(domElm)) {\r\n            domElm = __docElement;\r\n            offset = {\r\n                top: $el.scrollTop(),\r\n                left: $el.scrollLeft()\r\n            };\r\n        } else {\r\n            offset = $el.offset();\r\n        }\r\n\r\n        return {\r\n            width: domElm.clientWidth,\r\n            height: domElm.clientHeight,\r\n            top: offset.top + domElm.clientTop,\r\n            left: offset.left + domElm.clientLeft\r\n        };\r\n    }\r\n\r\n    function __refreshBounding($el, normPos) {\r\n        var domElm = $el[0];\r\n        var offset;\r\n        if (domElm.nodeType === 9) {\r\n            // is document node\r\n            domElm = __docElement;\r\n            offset = {\r\n                top: 0,\r\n                left: 0\r\n            };\r\n        } else if ($.isWindow(domElm)) {\r\n            domElm = __docElement;\r\n            offset = {\r\n                top: $el.scrollTop(),\r\n                left: $el.scrollLeft()\r\n            };\r\n        } else {\r\n            offset = $el.offset();\r\n        }\r\n\r\n        normPos.top = offset.top + domElm.clientTop;\r\n        normPos.left = offset.left + domElm.clientLeft;\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * normalize given offset, convert percent values in pixel values.\r\n     *\r\n     * @param  {Object} offset      offset object with property x:{number}, y:{number}, mirror:{boolean}\r\n     * @param  {Object} size        with properties width:{number} and height:{number} }\r\n     * @return {Object}             offset object\r\n     */\r\n    function __normalizeExtraOffset(offset, size) {\r\n        return {\r\n            y: parseFloat(offset.y) * (__rgx_percent.test(offset.y) ? size.height / 100 :\r\n                1),\r\n            x: parseFloat(offset.x) * (__rgx_percent.test(offset.x) ? size.width / 100 :\r\n                1),\r\n            mirror: offset.mirror\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calculate the relative offset from top-left corner to the reference points\r\n     *\r\n     * @param  {NormPos} pos          Object with normalized position\r\n     * @param  {{x:number, y:number}} extraOffsets    [description]\r\n     * @param  {{x:string, y:string}} initialRefpoint [description]\r\n     * @return {RefPoints}            Object with offset for reference points\r\n     *                                { top:number, left:number, middle:number,\r\n     *                                  center:number, bottom:number, right:number }\r\n     */\r\n    function __calculateRefpointOffsets(pos, extraOffsets, initialRefpoint) {\r\n        var result = {\r\n            top: 0,\r\n            left: 0,\r\n            middle: pos.height * 0.5,\r\n            center: pos.width * 0.5,\r\n            bottom: pos.height,\r\n            right: pos.width\r\n        };\r\n\r\n        //add extra offset\r\n        if (extraOffsets.y !== 0) {\r\n            result.middle += extraOffsets.y;\r\n            if (extraOffsets.mirror) {\r\n                result.top += (\"top\" !== initialRefpoint.y) ? (extraOffsets.y * -1) :\r\n                    extraOffsets.y;\r\n                result.bottom += (\"bottom\" !== initialRefpoint.y) ? (extraOffsets.y * -1) :\r\n                    extraOffsets.y;\r\n            } else {\r\n                result.top += extraOffsets.y;\r\n                result.bottom += extraOffsets.y;\r\n            }\r\n        }\r\n        if (extraOffsets.x !== 0) {\r\n            result.center += extraOffsets.x;\r\n            if (extraOffsets.mirror) {\r\n                result.left += (\"left\" !== initialRefpoint.x) ? (extraOffsets.x * -1) :\r\n                    extraOffsets.x;\r\n                result.right += (\"right\" !== initialRefpoint.x) ? (extraOffsets.x * -1) :\r\n                    extraOffsets.x;\r\n            } else {\r\n                result.left += extraOffsets.x;\r\n                result.right += extraOffsets.x;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * collect all edges that have overflow between boundary and item.\r\n     *\r\n     * @param  {Distance} distance  Distance Object\r\n     * @return {Distance}           Object with\r\n     *                              { top:number, left:number, bottom:number, right:number,\r\n     *                                overflow:{Array.<string>|null} }\r\n     */\r\n    function __updateOverflow(distance) {\r\n        var overflow = [];\r\n        distance.top > 0 && overflow.push(\"top\");\r\n        distance.left > 0 && overflow.push(\"left\");\r\n        distance.bottom < 0 && overflow.push(\"bottom\");\r\n        distance.right < 0 && overflow.push(\"right\");\r\n\r\n        if (overflow.length) {\r\n            distance.overflow = overflow;\r\n        } else {\r\n            distance.overflow = null;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * calculate distance / overflow between boundary and item.\r\n     *\r\n     * @param  {NormPos} bou_Pos    NormPos of boundary\r\n     * @param  {NormPos} item_Pos   NormPos of item\r\n     * @return {Distance}           Object with\r\n     *                              { top:number, left:number, bottom:number, right:number,\r\n     *                                overflow:{Array.<string>|null} }\r\n     */\r\n    function __calulateDistance(bou_Pos, item_Pos) {\r\n        var result = {\r\n            top: bou_Pos.top - item_Pos.top,\r\n            left: bou_Pos.left - item_Pos.left,\r\n            bottom: (bou_Pos.top + bou_Pos.height) - (item_Pos.top + item_Pos.height),\r\n            right: (bou_Pos.left + bou_Pos.width) - (item_Pos.left + item_Pos.width),\r\n            overflow: []\r\n        };\r\n\r\n        return __updateOverflow(result);\r\n    }\r\n\r\n    /**\r\n     * calculate the new fliped placement.\r\n     *\r\n     * {NormAt} is Object with {x:string, y:string}\r\n     *\r\n     * @param  {string} flip    - flip option, \"item\", \"target\", \"both\", \"none\"\r\n     * @param  {NormAt} itemAt  - NormAt of item\r\n     * @param  {NormAt} tarAt   - NormAt of target\r\n     * @param  {Distance}       - current calculated distance, needed to find out, which edge have overflow\r\n     * @return {Object|null}    - Object with placement\r\n     *                          {\r\n     *                              item_at:NormAt,\r\n     *                              tar_at:NormAt\r\n     *                          }\r\n     *                          - null, if no overflow or if overflow on all edges\r\n     */\r\n    function __flipPlacement(flip, itemAt, tarAt, distance) {\r\n        var y_overflowEdge, x_overflowEdge, flipBits;\r\n        var item_flipedAt = {\r\n            y: itemAt.y,\r\n            x: itemAt.x\r\n        };\r\n        var tar_flipedAt = {\r\n            y: tarAt.y,\r\n            x: tarAt.x\r\n        };\r\n\r\n        if (distance.overflow.indexOf(\"top\") !== -1) {\r\n            y_overflowEdge = \"top\";\r\n        }\r\n        if (distance.overflow.indexOf(\"bottom\") !== -1) {\r\n            if (y_overflowEdge) {\r\n                //overflow in both sides, so item is larger than boundary. Can't be resolved\r\n                y_overflowEdge = null;\r\n            } else {\r\n                y_overflowEdge = \"bottom\";\r\n            }\r\n        }\r\n\r\n        if (distance.overflow.indexOf(\"left\") !== -1) {\r\n            x_overflowEdge = \"left\";\r\n        }\r\n        if (distance.overflow.indexOf(\"right\") !== -1) {\r\n            if (x_overflowEdge) {\r\n                //overflow in both sides, so item is larger than boundary. Can't be resolved\r\n                x_overflowEdge = null;\r\n            } else {\r\n                x_overflowEdge = \"right\";\r\n            }\r\n        }\r\n\r\n        if (!y_overflowEdge && !x_overflowEdge) {\r\n            return null;\r\n        }\r\n\r\n        flip = (flip === true) ? \"both\" : flip;\r\n        flipBits = 0;\r\n        switch (flip) {\r\n            case \"item\":\r\n                flipBits = 1;\r\n                break;\r\n            case \"target\":\r\n                flipBits = 2;\r\n                break;\r\n            case \"both\":\r\n                flipBits = 3;\r\n                break;\r\n        }\r\n\r\n        if (flipBits & 1) {\r\n            y_overflowEdge && (item_flipedAt.y = __mirror[item_flipedAt.y]);\r\n            x_overflowEdge && (item_flipedAt.x = __mirror[item_flipedAt.x]);\r\n        }\r\n        if (flipBits & 2) {\r\n            y_overflowEdge && (tar_flipedAt.y = __mirror[tar_flipedAt.y]);\r\n            x_overflowEdge && (tar_flipedAt.x = __mirror[tar_flipedAt.x]);\r\n        }\r\n\r\n        return {\r\n            item_at: item_flipedAt,\r\n            tar_at: tar_flipedAt\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * compare overflow in distancaA with overflow in distanceB.\r\n     *\r\n     * @param  {Distance}  distanceA  distance object, with top, right, bottom, left\r\n     * @param  {Distance}  distanceB  distance object, with top, right, bottom, left\r\n     * @param  {boolean} isY        axis\r\n     * @return {boolean}            return true, if overflow of A is less than overflow of B,\r\n     *                                         otherwise false\r\n     */\r\n    function __overflowLT(distanceA, distanceB, isY) {\r\n        var a1, a2, b1, b2, edges;\r\n\r\n        if (isY) {\r\n            edges = [\"top\", \"bottom\"];\r\n        } else {\r\n            edges = [\"left\", \"right\"];\r\n        }\r\n        a1 = distanceA[edges[0]];\r\n        b1 = distanceB[edges[0]];\r\n        a2 = distanceA[edges[1]] * -1; // * -1 to get positive values for overflow\r\n        b2 = distanceB[edges[1]] * -1;\r\n\r\n        // set values without overflow to zero\r\n        a1 < 0 && (a1 = 0);\r\n        a2 < 0 && (a2 = 0);\r\n        b1 < 0 && (b1 = 0);\r\n        b2 < 0 && (b2 = 0);\r\n\r\n        if (a1 < 0 && a2 < 0) {\r\n            //take a\r\n            return true;\r\n        }\r\n\r\n        if (b1 < 0 && b2 < 0) {\r\n            // take b\r\n            return false;\r\n        }\r\n\r\n        return (a1 + a2) < (b1 + b2);\r\n    }\r\n\r\n    function __adaptSticking(data, edges) {\r\n        if (edges === \"all\") {\r\n            edges = true;\r\n        }\r\n        var overflow = data.distance.overflow;\r\n\r\n        if(!overflow.length) {\r\n            return data;\r\n        }\r\n\r\n        //to prevent handling overflow in both directions of on axis\r\n        var skipX = false;\r\n        var skipY = false;\r\n\r\n        var edge, diff;\r\n        for (var i = overflow.length - 1; i >= 0; i--) {\r\n            edge = overflow[i];\r\n            switch (edge) {\r\n                case \"top\":\r\n                case \"bottom\":\r\n                    if (!skipY && edges === true || edges.indexOf(edge) !== -1) {\r\n                        diff = data.distance[edge];\r\n                        data.moveBy.y += diff;\r\n                        data.distance.top -= diff;\r\n                        data.distance.bottom -= diff;\r\n                        skipY = true;\r\n                    }\r\n                    break;\r\n\r\n                case \"left\":\r\n                case \"right\":\r\n                    if (!skipX && edges === true || edges.indexOf(edge) !== -1) {\r\n                        diff = data.distance[edge];\r\n                        data.moveBy.x += diff;\r\n                        data.distance.left -= diff;\r\n                        data.distance.right -= diff;\r\n                        skipX = true;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        __updateOverflow(data.distance);\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Class PositionCalculator\r\n     *\r\n     * @param {Object} options\r\n     *\r\n     * {selector|DOM|jQuery} item       -required- the element being positioned\r\n     * {selector|DOM|jQuery} target     -required- the element align the positioned item against\r\n     * {selector|DOM|jQuery|null} boundary -optional- constraints the position of item\r\n     *                                      default: window\r\n     *\r\n     * {string} itemAt          -optional- placement of reference point on the item\r\n     *                                   syntax: <vertical> + \" \" + <horizontal>\r\n     *                                   vertical: \"top\" | \"middle\" | \"bottom\"\r\n     *                                   horizontal: \"left\" | \"center\" | \"right\"\r\n     *                          default: \"top left\"\r\n     * {string} targetAt        -optional- placement of reference point on the target\r\n     *                                     same as for \"itemAt\"\r\n     *                          default: \"top left\"\r\n     * {Object} itemOffset      -optional- Object with {\r\n     *                                         y:number,      // vertical offset\r\n     *                                         x:number,      // horizontal offset\r\n     *                                         mirror:boolean // if offset should mirror for flip\r\n     *                                    }\r\n     *                          default: { y:0, x:0, mirror:true }\r\n     *\r\n     * {Object} targetOffset    -optional- same as for \"itemOffset\"\r\n     *                          default: { y:0, x:0, mirror:true }\r\n     *\r\n     * {string|boolean} flip    -optional- specify the strategy to prevent that \"item\"\r\n     *                                    overflows the boundary.\r\n     *                                    \"item\": Only change the itemAt\r\n     *                                    \"target\": Only change the targetAt\r\n     *                                    \"both\"|true: Change both the itemAt and targetAt at the same time\r\n     *                                          (to 'flip' the item to the other side of the target)\r\n     *                                    \"none\"|false: Don't change placement of reference point\r\n     *                          default: \"none\"\r\n     *\r\n     * {string|boolean} stick   -optional- will keep the item within it's boundary by sticking it to\r\n     *                                     the edges if it normally would overflow.\r\n     *                                     Specify sides you'd like to control (space separated) or\r\n     *                                     \"none\"|false or \"all\"|true.\r\n     *                          default: \"none\"\r\n     *\r\n     *\r\n     *  Main method is calculate()\r\n     *\r\n     */\r\n    function PositionCalculator(options) {\r\n        //ensure it called with 'new'\r\n        if (!(this instanceof PositionCalculator)) {\r\n            return new PositionCalculator(options);\r\n        }\r\n\r\n        this.options =\r\n            this.$itm =\r\n            this.$trg =\r\n            this.$bnd =\r\n            this.itmAt =\r\n            this.trgAt =\r\n            this.itmPos =\r\n            this.trgPos =\r\n            this.bndPos =\r\n            this.itmOffset =\r\n            this.trgOffset = null;\r\n\r\n        this._init(options);\r\n    }\r\n    PositionCalculator.prototype._init = function(options) {\r\n        var o = this.options = $.extend({}, PositionCalculator.defaults, options);\r\n\r\n        if (!o.item) {\r\n            return null;\r\n        }\r\n        this.$itm = o.item.jquery ? o.item : $(o.item);\r\n        if (this.$itm.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        this.$trg = o.target && o.target.jquery ? o.target : $(__normalizeSlector(o.target));\r\n        this.$bnd = o.boundary && o.boundary.jquery ? o.boundary : $(__normalizeSlector(o.boundary));\r\n\r\n        this.itmAt = __normalizeAt(o.itemAt);\r\n        this.trgAt = __normalizeAt(o.targetAt);\r\n\r\n        this.resize();\r\n\r\n        return this; // to allow chaining\r\n    };\r\n\r\n    /**\r\n     * Update intern stored values depending on size and position of elements (item, target, boundary).\r\n     * Should be called if dimensions of an element changed.\r\n     *\r\n     * @return {this} allow chaining\r\n     */\r\n    PositionCalculator.prototype.resize = function() {\r\n        var o = this.options;\r\n\r\n        var item_pos = __nomrmalizePosition(this.$itm);\r\n        var targ_pos = this.$trg.length ? __nomrmalizePosition(this.$trg) : null;\r\n        this.bndPos = this.$bnd.length ? __normalizeBounding(this.$bnd) : null;\r\n\r\n        if (!this.itmPos || !__isEqualNormPos(item_pos, this.itmPos)) {\r\n            this.itmPos = item_pos;\r\n            var item_extraOffset = __normalizeExtraOffset(o.itemOffset, item_pos);\r\n            // negate values, because it shall be defined relative to the item reference point\r\n            // and not relative to the corner.\r\n            item_extraOffset.x = item_extraOffset.x * -1;\r\n            item_extraOffset.y = item_extraOffset.y * -1;\r\n\r\n            this.itmOffset = __calculateRefpointOffsets(item_pos, item_extraOffset,\r\n                this.itmAt);\r\n        }\r\n        if (!this.trgPos || !__isEqualNormPos(targ_pos, this.trgPos)) {\r\n            this.trgPos = targ_pos;\r\n            if(targ_pos) {\r\n                this.trgOffset = __calculateRefpointOffsets(\r\n                    targ_pos,\r\n                    __normalizeExtraOffset(o.targetOffset, targ_pos),\r\n                    this.trgAt\r\n                );\r\n            }\r\n        }\r\n\r\n        return this; // to allow chaining\r\n    };\r\n\r\n    /**\r\n     * Calculate the resulting position and boundary distance for the given placement.\r\n     * That will not handle flip and fit.\r\n     *\r\n     * If target was not specified, only boundary distance will be calculated.\r\n     * If not \"item_at\" or \"tar_at\", only boundary distance will be calculated.\r\n     * If boundary was set to null, only new position will be calculated.\r\n     *\r\n     * Current position of elements (item, target, boundary) will be read from DOM.\r\n     *\r\n     * @param  {{x:string, y:string}|null} item_at Placement for reference point on item\r\n     * @param  {{x:string, y:string}|null} tar_at  Placement for reference point on target\r\n     * @return {Object}         CalculationResult, see method calculate()\r\n     */\r\n    PositionCalculator.prototype.calcVariant = function(item_at, tar_at) {\r\n        var result = {\r\n            moveBy: null,\r\n            distance: null,\r\n            itemAt: null,\r\n            targetAt: null\r\n        };\r\n\r\n        if(this.trgPos && item_at && tar_at) {\r\n            var tar_refpoint = {\r\n                top: this.trgPos.top + this.trgOffset[tar_at.y],\r\n                left: this.trgPos.left + this.trgOffset[tar_at.x]\r\n            };\r\n            var item_newPos = {\r\n                top: tar_refpoint.top - this.itmOffset[item_at.y],\r\n                left: tar_refpoint.left - this.itmOffset[item_at.x],\r\n                height: this.itmPos.height,\r\n                width: this.itmPos.width\r\n            };\r\n\r\n            result.moveBy = {\r\n                y: item_newPos.top - this.itmPos.top,\r\n                x: item_newPos.left - this.itmPos.left\r\n            };\r\n            result.distance = this.bndPos ? __calulateDistance(this.bndPos, item_newPos) : null;\r\n            result.itemAt = item_at.y + \" \" + item_at.x;\r\n            result.targetAt = tar_at.y + \" \" + tar_at.x;\r\n        } else {\r\n            result.moveBy = { y:0, x:0 };\r\n            result.distance = this.bndPos ? __calulateDistance(this.bndPos, this.itmPos) : null;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Calculate the distance between reference point of item and reference point of target and\r\n     * handle overflow in the specified matter.\r\n     *\r\n     * @return {Object}   with:\r\n     *     moveBy: {{y:number, x:number}} - distance between target and item as pixel values\r\n     *     distance: {Distance|null}    - distance between item and boundary\r\n     *                                      null, if boundary was not given\r\n     *                                  Distance is Object with: {\r\n     *                                      top:number, left:number,\r\n     *                                      bottom:number, right:number,\r\n     *                                      overflow:{Array.<string>|null}\r\n     *                                  }\r\n     *                                  - top, left, buttom, right - distance/overflow for this edge\r\n     *                                  - overflow - Array with edges has overflow\r\n     *                                             - null for no collision detected\r\n     *     itemAt: {string|null}        - used placement of reference point at item\r\n     *                                    syntax: <vertical> + \" \" + <horizontal>\r\n     *                                    vertical: \"top\" | \"middle\" | \"bottom\"\r\n     *                                    horizontal: \"left\" | \"center\" | \"right\"\r\n     *                                  - null, if target was not given\r\n     *     targetAt: {string|null}      - used placement of reference point at target\r\n     *                                    syntax: <vertical> + \" \" + <horizontal>\r\n     *                                    vertical: \"top\" | \"middle\" | \"bottom\"\r\n     *                                    horizontal: \"left\" | \"center\" | \"right\"\r\n     *                                  - null, if target was not given\r\n     */\r\n    PositionCalculator.prototype.calculate = function() {\r\n        if (this.itmPos === null) {\r\n            return null; // init failed\r\n        }\r\n\r\n        var o = this.options;\r\n\r\n        // refresh\r\n        // only update the position off elements and scroll offsets, but not the width or height\r\n        __refreshPosition(this.$itm, this.itmPos);\r\n        this.trgPos && __refreshPosition(this.$trg, this.trgPos);\r\n        this.bndPos && __refreshBounding(this.$bnd, this.bndPos);\r\n\r\n        var result = this.calcVariant(this.itmAt, this.trgAt);\r\n        if (!result.distance || !result.distance.overflow) {\r\n            //finish, because no collision\r\n            return result;\r\n        }\r\n\r\n        // ////////////////////\r\n        // collision handling: flip\r\n        if (o.flip && o.flip !== \"none\" && this.trgPos) {\r\n            var newResult;\r\n            var flipedPlacement = __flipPlacement(o.flip, this.itmAt, this.trgAt,\r\n                result.distance);\r\n\r\n            if (flipedPlacement) {\r\n                newResult = this.calcVariant(flipedPlacement.item_at, flipedPlacement.tar_at);\r\n\r\n                if (!newResult.distance.overflow) {\r\n                    //finish, because found placement without collision\r\n                    return newResult;\r\n                }\r\n\r\n                // look for combination with fewest overflow\r\n                var useNew = {\r\n                    y: false,\r\n                    x: false\r\n                };\r\n                useNew.y = __overflowLT(newResult.distance, result.distance, true);\r\n                useNew.x = __overflowLT(newResult.distance, result.distance, false);\r\n\r\n                if (useNew.y !== useNew.x) {\r\n                    //need new distance calculation\r\n                    result = this.calcVariant({\r\n                        y: useNew.y ? flipedPlacement.item_at.y : this.itmAt.y,\r\n                        x: useNew.x ? flipedPlacement.item_at.x : this.itmAt.x\r\n                    }, {\r\n                        y: useNew.y ? flipedPlacement.tar_at.y : this.trgAt.y,\r\n                        x: useNew.x ? flipedPlacement.tar_at.x : this.trgAt.x\r\n                    });\r\n                    if (!result.distance.overflow) {\r\n                        //finish, because found position without collision\r\n                        return result;\r\n                    }\r\n                } else if (useNew.y && useNew.x) {\r\n                    result = newResult;\r\n                } // else use \"old\" result\r\n            }\r\n        }\r\n\r\n        // ////////////////////\r\n        // collision handling: stick\r\n        if (o.stick && o.stick !== \"none\") {\r\n            return __adaptSticking(result, o.stick);\r\n        } else {\r\n            return result;\r\n        }\r\n    };\r\n\r\n    // default options\r\n    PositionCalculator.defaults = {\r\n        item: null,\r\n        target: null,\r\n        boundary: window,\r\n        itemAt: \"top left\",\r\n        targetAt: \"top left\",\r\n        itemOffset: {\r\n            y: 0,\r\n            x: 0,\r\n            mirror: true\r\n        },\r\n        targetOffset: {\r\n            y: 0,\r\n            x: 0,\r\n            mirror: true\r\n        },\r\n        flip: \"none\",\r\n        stick: \"none\"\r\n    };\r\n\r\n    // export\r\n    return PositionCalculator;\r\n}));\r\n"],
  "mappings": ";;;;;;;AAAA;AAAA;AASA,OAAC,SAAS,SAAS;AAEf,YAAI,OAAO,WAAW,cAAc,OAAO,KAAK;AAE5C,iBAAO,uBAAuB,CAAC,QAAQ,GAAG,OAAO;AAAA,QACrD,WAAW,OAAO,WAAW,YAAY,OAAO,SAAS;AACrD,iBAAO,UAAU;AAAA,QACrB,OAAO;AAEH,iBAAO,qBAAqB,QAAQ,MAAM;AAAA,QAC9C;AAAA,MACJ,GAAE,SAAS,GAAG;AACV;AAIA,YAAI,WAAW;AACf,YAAI,aAAa;AACjB,YAAI,eAAe,WAAW;AAE9B,YAAI,iBAAiB;AACrB,YAAI,mBAAmB;AACvB,YAAI,gBAAgB;AAEpB,YAAI,WAAW;AAAA,UACX,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,OAAO;AAAA,UACP,KAAK;AAAA,UACL,QAAQ;AAAA,UACR,QAAQ;AAAA,QACZ;AASA,iBAAS,mBAAmB,UAAU;AAClC,cAAI,OAAO,aAAa,UAAU;AAC9B,gBAAI,aAAa,UAAU;AACvB,yBAAW;AAAA,YACf,WAAW,aAAa,YAAY;AAChC,yBAAW;AAAA,YACf;AAAA,UACJ;AACA,iBAAO;AAAA,QACX;AAWA,iBAAS,cAAc,KAAK;AACxB,cAAI,SAAS,IAAI,MAAM,GAAG;AAC1B,iBAAO;AAAA,YACH,GAAG,eAAe,KAAK,OAAO,EAAE,IAAI,OAAO,KAAK;AAAA,YAChD,GAAG,iBAAiB,KAAK,OAAO,EAAE,IAAI,OAAO,KAAK;AAAA,UACtD;AAAA,QACJ;AASA,iBAAS,iBAAiB,UAAU,UAAU;AAC1C,cAAI,aAAa,UAAU;AACvB,mBAAO;AAAA,UACX;AACA,cAAG,CAAC,YAAY,CAAC,UAAU;AACvB,mBAAO;AAAA,UACX;AACA,iBAAQ,SAAS,QAAQ,SAAS,OAAO,SAAS,SAAS,SAAS,QAChE,SAAS,WAAW,SAAS,UAAU,SAAS,UAAU,SAAS;AAAA,QAC3E;AAWA,iBAAS,qBAAqB,KAAK;AAC/B,cAAI,MAAM,IAAI;AACd,cAAI,IAAI,aAAa,GAAG;AAEpB,mBAAO;AAAA,cACH,OAAO,IAAI,WAAW;AAAA,cACtB,QAAQ,IAAI,YAAY;AAAA,cACxB,KAAK;AAAA,cACL,MAAM;AAAA,YACV;AAAA,UACJ;AACA,cAAI,EAAE,SAAS,GAAG,GAAG;AACjB,mBAAO;AAAA,cACH,OAAO,IAAI,WAAW;AAAA,cACtB,QAAQ,IAAI,YAAY;AAAA,cACxB,KAAK,IAAI,UAAU;AAAA,cACnB,MAAM,IAAI,WAAW;AAAA,YACzB;AAAA,UACJ;AACA,cAAI,IAAI,gBAAgB;AAEpB,mBAAO;AAAA,cACH,OAAO;AAAA,cACP,QAAQ;AAAA,cACR,KAAK,IAAI;AAAA,cACT,MAAM,IAAI;AAAA,YACd;AAAA,UACJ;AACA,cAAI,SAAS,IAAI,OAAO;AACxB,iBAAO;AAAA,YACH,OAAO,IAAI,WAAW;AAAA,YACtB,QAAQ,IAAI,YAAY;AAAA,YACxB,KAAK,OAAO;AAAA,YACZ,MAAM,OAAO;AAAA,UACjB;AAAA,QACJ;AAEA,iBAAS,kBAAkB,KAAK,SAAS;AACrC,cAAI,MAAM,IAAI;AACd,cAAI,IAAI,aAAa,GAAG;AAEpB;AAAA,UACJ;AACA,cAAI,EAAE,SAAS,GAAG,GAAG;AACjB,oBAAQ,MAAM,IAAI,UAAU;AAC5B,oBAAQ,OAAO,IAAI,WAAW;AAAA,UAClC;AACA,cAAI,IAAI,gBAAgB;AAEpB,oBAAQ,MAAM,IAAI;AAClB,oBAAQ,OAAO,IAAI;AACnB;AAAA,UACJ;AAEA,cAAI,SAAS,IAAI,OAAO;AACxB,kBAAQ,MAAM,OAAO;AACrB,kBAAQ,OAAO,OAAO;AACtB;AAAA,QACJ;AAUA,iBAAS,oBAAoB,KAAK;AAC9B,cAAI,SAAS,IAAI;AACjB,cAAI;AACJ,cAAI,OAAO,aAAa,GAAG;AAEvB,qBAAS;AACT,qBAAS;AAAA,cACL,KAAK;AAAA,cACL,MAAM;AAAA,YACV;AAAA,UACJ,WAAW,EAAE,SAAS,MAAM,GAAG;AAC3B,qBAAS;AACT,qBAAS;AAAA,cACL,KAAK,IAAI,UAAU;AAAA,cACnB,MAAM,IAAI,WAAW;AAAA,YACzB;AAAA,UACJ,OAAO;AACH,qBAAS,IAAI,OAAO;AAAA,UACxB;AAEA,iBAAO;AAAA,YACH,OAAO,OAAO;AAAA,YACd,QAAQ,OAAO;AAAA,YACf,KAAK,OAAO,MAAM,OAAO;AAAA,YACzB,MAAM,OAAO,OAAO,OAAO;AAAA,UAC/B;AAAA,QACJ;AAEA,iBAAS,kBAAkB,KAAK,SAAS;AACrC,cAAI,SAAS,IAAI;AACjB,cAAI;AACJ,cAAI,OAAO,aAAa,GAAG;AAEvB,qBAAS;AACT,qBAAS;AAAA,cACL,KAAK;AAAA,cACL,MAAM;AAAA,YACV;AAAA,UACJ,WAAW,EAAE,SAAS,MAAM,GAAG;AAC3B,qBAAS;AACT,qBAAS;AAAA,cACL,KAAK,IAAI,UAAU;AAAA,cACnB,MAAM,IAAI,WAAW;AAAA,YACzB;AAAA,UACJ,OAAO;AACH,qBAAS,IAAI,OAAO;AAAA,UACxB;AAEA,kBAAQ,MAAM,OAAO,MAAM,OAAO;AAClC,kBAAQ,OAAO,OAAO,OAAO,OAAO;AACpC;AAAA,QACJ;AASA,iBAAS,uBAAuB,QAAQ,MAAM;AAC1C,iBAAO;AAAA,YACH,GAAG,WAAW,OAAO,CAAC,KAAK,cAAc,KAAK,OAAO,CAAC,IAAI,KAAK,SAAS,MACpE;AAAA,YACJ,GAAG,WAAW,OAAO,CAAC,KAAK,cAAc,KAAK,OAAO,CAAC,IAAI,KAAK,QAAQ,MACnE;AAAA,YACJ,QAAQ,OAAO;AAAA,UACnB;AAAA,QACJ;AAYA,iBAAS,2BAA2B,KAAK,cAAc,iBAAiB;AACpE,cAAI,SAAS;AAAA,YACT,KAAK;AAAA,YACL,MAAM;AAAA,YACN,QAAQ,IAAI,SAAS;AAAA,YACrB,QAAQ,IAAI,QAAQ;AAAA,YACpB,QAAQ,IAAI;AAAA,YACZ,OAAO,IAAI;AAAA,UACf;AAGA,cAAI,aAAa,MAAM,GAAG;AACtB,mBAAO,UAAU,aAAa;AAC9B,gBAAI,aAAa,QAAQ;AACrB,qBAAO,OAAQ,UAAU,gBAAgB,IAAM,aAAa,IAAI,KAC5D,aAAa;AACjB,qBAAO,UAAW,aAAa,gBAAgB,IAAM,aAAa,IAAI,KAClE,aAAa;AAAA,YACrB,OAAO;AACH,qBAAO,OAAO,aAAa;AAC3B,qBAAO,UAAU,aAAa;AAAA,YAClC;AAAA,UACJ;AACA,cAAI,aAAa,MAAM,GAAG;AACtB,mBAAO,UAAU,aAAa;AAC9B,gBAAI,aAAa,QAAQ;AACrB,qBAAO,QAAS,WAAW,gBAAgB,IAAM,aAAa,IAAI,KAC9D,aAAa;AACjB,qBAAO,SAAU,YAAY,gBAAgB,IAAM,aAAa,IAAI,KAChE,aAAa;AAAA,YACrB,OAAO;AACH,qBAAO,QAAQ,aAAa;AAC5B,qBAAO,SAAS,aAAa;AAAA,YACjC;AAAA,UACJ;AAEA,iBAAO;AAAA,QACX;AAUA,iBAAS,iBAAiB,UAAU;AAChC,cAAI,WAAW,CAAC;AAChB,mBAAS,MAAM,KAAK,SAAS,KAAK,KAAK;AACvC,mBAAS,OAAO,KAAK,SAAS,KAAK,MAAM;AACzC,mBAAS,SAAS,KAAK,SAAS,KAAK,QAAQ;AAC7C,mBAAS,QAAQ,KAAK,SAAS,KAAK,OAAO;AAE3C,cAAI,SAAS,QAAQ;AACjB,qBAAS,WAAW;AAAA,UACxB,OAAO;AACH,qBAAS,WAAW;AAAA,UACxB;AAEA,iBAAO;AAAA,QACX;AAWA,iBAAS,mBAAmB,SAAS,UAAU;AAC3C,cAAI,SAAS;AAAA,YACT,KAAK,QAAQ,MAAM,SAAS;AAAA,YAC5B,MAAM,QAAQ,OAAO,SAAS;AAAA,YAC9B,QAAS,QAAQ,MAAM,QAAQ,UAAW,SAAS,MAAM,SAAS;AAAA,YAClE,OAAQ,QAAQ,OAAO,QAAQ,SAAU,SAAS,OAAO,SAAS;AAAA,YAClE,UAAU,CAAC;AAAA,UACf;AAEA,iBAAO,iBAAiB,MAAM;AAAA,QAClC;AAkBA,iBAAS,gBAAgB,MAAM,QAAQ,OAAO,UAAU;AACpD,cAAI,gBAAgB,gBAAgB;AACpC,cAAI,gBAAgB;AAAA,YAChB,GAAG,OAAO;AAAA,YACV,GAAG,OAAO;AAAA,UACd;AACA,cAAI,eAAe;AAAA,YACf,GAAG,MAAM;AAAA,YACT,GAAG,MAAM;AAAA,UACb;AAEA,cAAI,SAAS,SAAS,QAAQ,KAAK,MAAM,IAAI;AACzC,6BAAiB;AAAA,UACrB;AACA,cAAI,SAAS,SAAS,QAAQ,QAAQ,MAAM,IAAI;AAC5C,gBAAI,gBAAgB;AAEhB,+BAAiB;AAAA,YACrB,OAAO;AACH,+BAAiB;AAAA,YACrB;AAAA,UACJ;AAEA,cAAI,SAAS,SAAS,QAAQ,MAAM,MAAM,IAAI;AAC1C,6BAAiB;AAAA,UACrB;AACA,cAAI,SAAS,SAAS,QAAQ,OAAO,MAAM,IAAI;AAC3C,gBAAI,gBAAgB;AAEhB,+BAAiB;AAAA,YACrB,OAAO;AACH,+BAAiB;AAAA,YACrB;AAAA,UACJ;AAEA,cAAI,CAAC,kBAAkB,CAAC,gBAAgB;AACpC,mBAAO;AAAA,UACX;AAEA,iBAAQ,SAAS,OAAQ,SAAS;AAClC,qBAAW;AACX,kBAAQ,MAAM;AAAA,YACV,KAAK;AACD,yBAAW;AACX;AAAA,YACJ,KAAK;AACD,yBAAW;AACX;AAAA,YACJ,KAAK;AACD,yBAAW;AACX;AAAA,UACR;AAEA,cAAI,WAAW,GAAG;AACd,+BAAmB,cAAc,IAAI,SAAS,cAAc;AAC5D,+BAAmB,cAAc,IAAI,SAAS,cAAc;AAAA,UAChE;AACA,cAAI,WAAW,GAAG;AACd,+BAAmB,aAAa,IAAI,SAAS,aAAa;AAC1D,+BAAmB,aAAa,IAAI,SAAS,aAAa;AAAA,UAC9D;AAEA,iBAAO;AAAA,YACH,SAAS;AAAA,YACT,QAAQ;AAAA,UACZ;AAAA,QACJ;AAYA,iBAAS,aAAa,WAAW,WAAW,KAAK;AAC7C,cAAI,IAAI,IAAI,IAAI,IAAI;AAEpB,cAAI,KAAK;AACL,oBAAQ,CAAC,OAAO,QAAQ;AAAA,UAC5B,OAAO;AACH,oBAAQ,CAAC,QAAQ,OAAO;AAAA,UAC5B;AACA,eAAK,UAAU,MAAM;AACrB,eAAK,UAAU,MAAM;AACrB,eAAK,UAAU,MAAM,MAAM;AAC3B,eAAK,UAAU,MAAM,MAAM;AAG3B,eAAK,MAAM,KAAK;AAChB,eAAK,MAAM,KAAK;AAChB,eAAK,MAAM,KAAK;AAChB,eAAK,MAAM,KAAK;AAEhB,cAAI,KAAK,KAAK,KAAK,GAAG;AAElB,mBAAO;AAAA,UACX;AAEA,cAAI,KAAK,KAAK,KAAK,GAAG;AAElB,mBAAO;AAAA,UACX;AAEA,iBAAQ,KAAK,KAAO,KAAK;AAAA,QAC7B;AAEA,iBAAS,gBAAgB,MAAM,OAAO;AAClC,cAAI,UAAU,OAAO;AACjB,oBAAQ;AAAA,UACZ;AACA,cAAI,WAAW,KAAK,SAAS;AAE7B,cAAG,CAAC,SAAS,QAAQ;AACjB,mBAAO;AAAA,UACX;AAGA,cAAI,QAAQ;AACZ,cAAI,QAAQ;AAEZ,cAAI,MAAM;AACV,mBAAS,IAAI,SAAS,SAAS,GAAG,KAAK,GAAG,KAAK;AAC3C,mBAAO,SAAS;AAChB,oBAAQ,MAAM;AAAA,cACV,KAAK;AAAA,cACL,KAAK;AACD,oBAAI,CAAC,SAAS,UAAU,QAAQ,MAAM,QAAQ,IAAI,MAAM,IAAI;AACxD,yBAAO,KAAK,SAAS;AACrB,uBAAK,OAAO,KAAK;AACjB,uBAAK,SAAS,OAAO;AACrB,uBAAK,SAAS,UAAU;AACxB,0BAAQ;AAAA,gBACZ;AACA;AAAA,cAEJ,KAAK;AAAA,cACL,KAAK;AACD,oBAAI,CAAC,SAAS,UAAU,QAAQ,MAAM,QAAQ,IAAI,MAAM,IAAI;AACxD,yBAAO,KAAK,SAAS;AACrB,uBAAK,OAAO,KAAK;AACjB,uBAAK,SAAS,QAAQ;AACtB,uBAAK,SAAS,SAAS;AACvB,0BAAQ;AAAA,gBACZ;AACA;AAAA,YACR;AAAA,UACJ;AAEA,2BAAiB,KAAK,QAAQ;AAE9B,iBAAO;AAAA,QACX;AAiDA,iBAAS,mBAAmB,SAAS;AAEjC,cAAI,EAAE,gBAAgB,qBAAqB;AACvC,mBAAO,IAAI,mBAAmB,OAAO;AAAA,UACzC;AAEA,eAAK,UACD,KAAK,OACL,KAAK,OACL,KAAK,OACL,KAAK,QACL,KAAK,QACL,KAAK,SACL,KAAK,SACL,KAAK,SACL,KAAK,YACL,KAAK,YAAY;AAErB,eAAK,MAAM,OAAO;AAAA,QACtB;AACA,2BAAmB,UAAU,QAAQ,SAAS,SAAS;AACnD,cAAI,IAAI,KAAK,UAAU,EAAE,OAAO,CAAC,GAAG,mBAAmB,UAAU,OAAO;AAExE,cAAI,CAAC,EAAE,MAAM;AACT,mBAAO;AAAA,UACX;AACA,eAAK,OAAO,EAAE,KAAK,SAAS,EAAE,OAAO,EAAE,EAAE,IAAI;AAC7C,cAAI,KAAK,KAAK,WAAW,GAAG;AACxB,mBAAO;AAAA,UACX;AAEA,eAAK,OAAO,EAAE,UAAU,EAAE,OAAO,SAAS,EAAE,SAAS,EAAE,mBAAmB,EAAE,MAAM,CAAC;AACnF,eAAK,OAAO,EAAE,YAAY,EAAE,SAAS,SAAS,EAAE,WAAW,EAAE,mBAAmB,EAAE,QAAQ,CAAC;AAE3F,eAAK,QAAQ,cAAc,EAAE,MAAM;AACnC,eAAK,QAAQ,cAAc,EAAE,QAAQ;AAErC,eAAK,OAAO;AAEZ,iBAAO;AAAA,QACX;AAQA,2BAAmB,UAAU,SAAS,WAAW;AAC7C,cAAI,IAAI,KAAK;AAEb,cAAI,WAAW,qBAAqB,KAAK,IAAI;AAC7C,cAAI,WAAW,KAAK,KAAK,SAAS,qBAAqB,KAAK,IAAI,IAAI;AACpE,eAAK,SAAS,KAAK,KAAK,SAAS,oBAAoB,KAAK,IAAI,IAAI;AAElE,cAAI,CAAC,KAAK,UAAU,CAAC,iBAAiB,UAAU,KAAK,MAAM,GAAG;AAC1D,iBAAK,SAAS;AACd,gBAAI,mBAAmB,uBAAuB,EAAE,YAAY,QAAQ;AAGpE,6BAAiB,IAAI,iBAAiB,IAAI;AAC1C,6BAAiB,IAAI,iBAAiB,IAAI;AAE1C,iBAAK,YAAY;AAAA,cAA2B;AAAA,cAAU;AAAA,cAClD,KAAK;AAAA,YAAK;AAAA,UAClB;AACA,cAAI,CAAC,KAAK,UAAU,CAAC,iBAAiB,UAAU,KAAK,MAAM,GAAG;AAC1D,iBAAK,SAAS;AACd,gBAAG,UAAU;AACT,mBAAK,YAAY;AAAA,gBACb;AAAA,gBACA,uBAAuB,EAAE,cAAc,QAAQ;AAAA,gBAC/C,KAAK;AAAA,cACT;AAAA,YACJ;AAAA,UACJ;AAEA,iBAAO;AAAA,QACX;AAgBA,2BAAmB,UAAU,cAAc,SAAS,SAAS,QAAQ;AACjE,cAAI,SAAS;AAAA,YACT,QAAQ;AAAA,YACR,UAAU;AAAA,YACV,QAAQ;AAAA,YACR,UAAU;AAAA,UACd;AAEA,cAAG,KAAK,UAAU,WAAW,QAAQ;AACjC,gBAAI,eAAe;AAAA,cACf,KAAK,KAAK,OAAO,MAAM,KAAK,UAAU,OAAO;AAAA,cAC7C,MAAM,KAAK,OAAO,OAAO,KAAK,UAAU,OAAO;AAAA,YACnD;AACA,gBAAI,cAAc;AAAA,cACd,KAAK,aAAa,MAAM,KAAK,UAAU,QAAQ;AAAA,cAC/C,MAAM,aAAa,OAAO,KAAK,UAAU,QAAQ;AAAA,cACjD,QAAQ,KAAK,OAAO;AAAA,cACpB,OAAO,KAAK,OAAO;AAAA,YACvB;AAEA,mBAAO,SAAS;AAAA,cACZ,GAAG,YAAY,MAAM,KAAK,OAAO;AAAA,cACjC,GAAG,YAAY,OAAO,KAAK,OAAO;AAAA,YACtC;AACA,mBAAO,WAAW,KAAK,SAAS,mBAAmB,KAAK,QAAQ,WAAW,IAAI;AAC/E,mBAAO,SAAS,QAAQ,IAAI,MAAM,QAAQ;AAC1C,mBAAO,WAAW,OAAO,IAAI,MAAM,OAAO;AAAA,UAC9C,OAAO;AACH,mBAAO,SAAS,EAAE,GAAE,GAAG,GAAE,EAAE;AAC3B,mBAAO,WAAW,KAAK,SAAS,mBAAmB,KAAK,QAAQ,KAAK,MAAM,IAAI;AAAA,UACnF;AAEA,iBAAO;AAAA,QACX;AA6BA,2BAAmB,UAAU,YAAY,WAAW;AAChD,cAAI,KAAK,WAAW,MAAM;AACtB,mBAAO;AAAA,UACX;AAEA,cAAI,IAAI,KAAK;AAIb,4BAAkB,KAAK,MAAM,KAAK,MAAM;AACxC,eAAK,UAAU,kBAAkB,KAAK,MAAM,KAAK,MAAM;AACvD,eAAK,UAAU,kBAAkB,KAAK,MAAM,KAAK,MAAM;AAEvD,cAAI,SAAS,KAAK,YAAY,KAAK,OAAO,KAAK,KAAK;AACpD,cAAI,CAAC,OAAO,YAAY,CAAC,OAAO,SAAS,UAAU;AAE/C,mBAAO;AAAA,UACX;AAIA,cAAI,EAAE,QAAQ,EAAE,SAAS,UAAU,KAAK,QAAQ;AAC5C,gBAAI;AACJ,gBAAI,kBAAkB;AAAA,cAAgB,EAAE;AAAA,cAAM,KAAK;AAAA,cAAO,KAAK;AAAA,cAC3D,OAAO;AAAA,YAAQ;AAEnB,gBAAI,iBAAiB;AACjB,0BAAY,KAAK,YAAY,gBAAgB,SAAS,gBAAgB,MAAM;AAE5E,kBAAI,CAAC,UAAU,SAAS,UAAU;AAE9B,uBAAO;AAAA,cACX;AAGA,kBAAI,SAAS;AAAA,gBACT,GAAG;AAAA,gBACH,GAAG;AAAA,cACP;AACA,qBAAO,IAAI,aAAa,UAAU,UAAU,OAAO,UAAU,IAAI;AACjE,qBAAO,IAAI,aAAa,UAAU,UAAU,OAAO,UAAU,KAAK;AAElE,kBAAI,OAAO,MAAM,OAAO,GAAG;AAEvB,yBAAS,KAAK,YAAY;AAAA,kBACtB,GAAG,OAAO,IAAI,gBAAgB,QAAQ,IAAI,KAAK,MAAM;AAAA,kBACrD,GAAG,OAAO,IAAI,gBAAgB,QAAQ,IAAI,KAAK,MAAM;AAAA,gBACzD,GAAG;AAAA,kBACC,GAAG,OAAO,IAAI,gBAAgB,OAAO,IAAI,KAAK,MAAM;AAAA,kBACpD,GAAG,OAAO,IAAI,gBAAgB,OAAO,IAAI,KAAK,MAAM;AAAA,gBACxD,CAAC;AACD,oBAAI,CAAC,OAAO,SAAS,UAAU;AAE3B,yBAAO;AAAA,gBACX;AAAA,cACJ,WAAW,OAAO,KAAK,OAAO,GAAG;AAC7B,yBAAS;AAAA,cACb;AAAA,YACJ;AAAA,UACJ;AAIA,cAAI,EAAE,SAAS,EAAE,UAAU,QAAQ;AAC/B,mBAAO,gBAAgB,QAAQ,EAAE,KAAK;AAAA,UAC1C,OAAO;AACH,mBAAO;AAAA,UACX;AAAA,QACJ;AAGA,2BAAmB,WAAW;AAAA,UAC1B,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,UAAU;AAAA,UACV,QAAQ;AAAA,UACR,UAAU;AAAA,UACV,YAAY;AAAA,YACR,GAAG;AAAA,YACH,GAAG;AAAA,YACH,QAAQ;AAAA,UACZ;AAAA,UACA,cAAc;AAAA,YACV,GAAG;AAAA,YACH,GAAG;AAAA,YACH,QAAQ;AAAA,UACZ;AAAA,UACA,MAAM;AAAA,UACN,OAAO;AAAA,QACX;AAGA,eAAO;AAAA,MACX,CAAC;AAAA;AAAA;",
  "names": []
}
